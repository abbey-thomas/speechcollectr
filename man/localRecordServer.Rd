% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/localRecordServer.R
\name{localRecordServer}
\alias{localRecordServer}
\title{Server function for Recording User Audio}
\usage{
localRecordServer(
  id = "record",
  trigger = NULL,
  outFile,
  overwrite = FALSE,
  writtenStim = NULL,
  writtenDelay = 500
)
}
\arguments{
\item{id}{The input ID associated with the record module. Must be the same as the id of \code{localRecordUI()}.}

\item{trigger}{A reactive expression (i.e., something wrapped in "shiny::reactive()") that will trigger the recording interface to appear and run. Default is "NULL", so the module will only run (and output a uniquely named file) each time the user clicks start. If using the default NULL trigger, you must call "shinyjs::showElement()" to make the recording interface appear!}

\item{outFile}{Character or reactive expression. Where to store the audio file. Can indicate any subdirectory of the present working directory. If dynamic, wrap in \code{reactive()}.}

\item{writtenStim}{Either a character vector (for a single, static stimulus) or a reactive expression (created with reactive, for a stimulus that should be updated from trial to trial) representing a written stimulus that a participant will read while recording.}

\item{writtenDelay}{Integer. How many milliseconds should elapse between the time the participant clicks \code{record} and the time the written stimulus appears? Defaults to 500. We recommend not using a value less than that.}

\item{Overwrite}{Boolean. Defaults to \code{FALSE} so that a unique digit is appended to each filename so that all recordings will be saved even when the filename value is the same. If \code{TRUE}, will overwrite a file of the same name.}
}
\value{
In the case of a NULL trigger, returns a reactive expression containing two values: (1) \code{n}: the number of files recorded and (2) \code{file}: a character vector with length \code{n}, where each element is the name of a recorded wav file. If \code{trigger} argument is not NULL, returns a reactive expression containing: (1) \code{n}: the number of attempts at recording the current file and (2) \code{file}: the filename where only the most recent attempt is saved (previous attempts have been overwritten). Also returns a 16 bit, 44.1 kHz wav file in a filename comprising \code{outPrefix} and a unique four digit number.
}
\description{
Same as \code{recordServer()}, but faster (suited to slow internet connections). The server function for recording user audio (using local scripts) enables the 'stop' button after the user begins recording and checks to make sure the user has given the website permission to record audio in their browser. Requires the UI \code{\link{localRecordUI}}.
}
\note{
The "start" and "stop" buttons from this module can be accessed in the server code with the "id" of the module as follows: \code{input[["id-start"]]} or \code{input[["id-stop"]]}
}
\examples{
if (interactive()) {
  library(shiny)
  library(shinyjs)
  ui <- fluidPage(
    actionButton("begin", "BEGIN"),
    localRecordUI(id ="rec")
  )

  # Using the default "NULL" trigger argument, the record server function will save
  # a new file every time the participant clicks start,
  # with a new name generated each time a participant clicks start.
  server <- function(input, output, session) {
    recording <- localRecordServer(id ="rec",
                          outPrefix = paste0("www/rec_samp"))

    # You'll need to make the recording interface visible though!
    # Which can be accomplished with shinyjs::showElement()
    observeEvent(input$begin, {
      showElement("rec")
    })
  }
 shinyApp(ui = ui, server = server)
}

# Alternatively an explicit trigger argument can be set as shown below
if (interactive()) {
  library(shiny)
  library(shinyjs)

  ui <- fluidPage(
    actionButton("begin", "BEGIN"),
    localRecordUI(id ="rec")
  )

  # Now a new filename will be used if and only if the participant clicks "begin"
  # Otherwise, the same file will be over-written
  # This is useful if we want to give a participant multiple attempts at recording...
  server <- function(input, output, session) {
    recording <- localRecordServer(id ="rec",
                          trigger = reactive(input$begin),
                          outPrefix = paste0("www/rec_samp"))

    # But let's say we don't want them to have more than 3 attempts to record the file
    # We can do this by attaching an event to the "stop" button of the recorder,
    # which is saved in the apps input list as "(id)-stop"
    observeEvent(input[["rec-stop"]], {
      if (recording()$n == 3) {
        hide("rec")
      }
    })
  }
 shinyApp(ui = ui, server = server)
}
}
\seealso{
Must be used with \code{\link{localRecordUI}}.

Other Audio recording module: 
\code{\link{localRecordUI}()},
\code{\link{recordServer}()},
\code{\link{recordUI}()}
}
\concept{Audio recording module}
